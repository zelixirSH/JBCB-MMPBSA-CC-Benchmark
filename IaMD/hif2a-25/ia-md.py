# This script was generated by OpenMM-Setup on 2021-05-08.
from openmm import *
from simtk.openmm.app import *
from simtk.unit import *
from sys import stdout,argv
import mdtraj as md
import numpy as np
from energyreporter import *
from amd import *


# Input Files
pdbfile = "hif2a-25.pdb"
grofile = "hif2a-25.gro"
outfile = f"iamd-hif2a-25"
gpuid = '0'
topfile = "topol.top"


# Input Files
gro = GromacsGroFile(grofile)
top = GromacsTopFile(topfile, includeDir='/root/miniconda3/envs/openmm_env/share/gromacs/top/',
    periodicBoxVectors=gro.getPeriodicBoxVectors())

# System Configuration
nonbondedMethod = PME
nonbondedCutoff = 1.0*nanometers
ewaldErrorTolerance = 0.0005
constraints = HBonds
rigidWater = True
constraintTolerance = 0.000001
hydrogenMass = 4.0*amu

# Integration Options
dt = 0.004 * picoseconds
temperature = 300*kelvin
friction = 1.0/picosecond
pressure = 1.0*atmospheres
barostatInterval = 25

# Simulation Options
emsteps =       1000       # default
eqsteps =    1250000       # 
mdsteps =  250000000       # 
exsteps =      25000       # 

platform = Platform.getPlatformByName('CUDA')
platformProperties = {'Precision': 'mixed',"DeviceIndex":gpuid}
#platformProperties["DeviceIndex"] = "0"
os.system("export OPENMM_CPU_THREADS=8")

# Output Options
dcdReporter  = DCDReporter(outfile+'.dcd', exsteps)
# pdbReporter  = PDBReporter(outfile+'.pdb', exsteps)
chkReporter  = CheckpointReporter(outfile+'.chk', exsteps*10)
datReporter0 = StateDataReporter(outfile+'.log', exsteps, totalSteps=mdsteps,
               step=True, speed=True, progress=True, potentialEnergy=True, 
               temperature=True,volume=True, separator=',')
datReporter1 = StateDataReporter(stdout, exsteps, step=True,
               time=True, potentialEnergy=True, kineticEnergy=True, totalEnergy=True,
               temperature=True, progress=True, volume=True, density=True,
               remainingTime=True, speed=True, totalSteps=mdsteps, separator=',')
datReporter2 = StateDataReporter(outfile+'.csv', exsteps, step=True,
               time=True, potentialEnergy=True, kineticEnergy=True, totalEnergy=True,
               temperature=True, progress=True, volume=True, density=True,
               remainingTime=True, speed=True, totalSteps=mdsteps, separator=',')

# Prepare the Simulation
print('Building system...')
topology = top.topology
positions = gro.positions
system = top.createSystem(nonbondedMethod=nonbondedMethod, nonbondedCutoff=nonbondedCutoff,
    constraints=constraints, rigidWater=rigidWater, ewaldErrorTolerance=ewaldErrorTolerance, hydrogenMass=hydrogenMass)
barostat = MonteCarloBarostat(pressure, temperature, barostatInterval)
system.addForce(barostat)


print("=================================================================")
numForces = system.getNumForces()
print(f"Number of forces in the system: {numForces}")
for i in range(numForces):
    force = system.getForce(i)
    print(f"Force {i}: {force}")

force = system.getForce(3)
print(force)

traj = md.load(pdbfile)
pocket_res = [6, 8, 10, 11, 12, 13, 14, 15, 16, 23, 27, 34, 39, 40, 42, 43, 44, 51, 54, 55, 56, 57, 58, 59, 64, 65, 66, 69, 70, 71, 72, 81, 82, 83, 84, 85, 86, 99, 101, 103]
print('pocket_res_num:', len(pocket_res))

pocket_ato = np.concatenate((traj.top.select(' '.join([f'resid {i-1}' for i in pocket_res])), traj.top.select('resname L01')))
torsion_force_0 = PeriodicTorsionForce()
torsion_force_1 = PeriodicTorsionForce()

a = 0
b = 0
for i in range(force.getNumTorsions()):
    if any([j in pocket_ato for j in force.getTorsionParameters(i)[:4]]):
        torsion_force_1.addTorsion(
                                    force.getTorsionParameters(i)[0],
                                    force.getTorsionParameters(i)[1],
                                    force.getTorsionParameters(i)[2],
                                    force.getTorsionParameters(i)[3],
                                    force.getTorsionParameters(i)[4],
                                    force.getTorsionParameters(i)[5],
                                    force.getTorsionParameters(i)[6],
        )
        a += 1
    else:
        torsion_force_0.addTorsion(
                                    force.getTorsionParameters(i)[0],
                                    force.getTorsionParameters(i)[1],
                                    force.getTorsionParameters(i)[2],
                                    force.getTorsionParameters(i)[3],
                                    force.getTorsionParameters(i)[4],
                                    force.getTorsionParameters(i)[5],
                                    force.getTorsionParameters(i)[6],
        )
        b += 1
print(force.getNumTorsions(), a, b)

system.addForce(torsion_force_0)
system.addForce(torsion_force_1)
system.removeForce(3)


numForces = system.getNumForces()
print(f"Number of forces in the system: {numForces}")
for i in range(numForces):
    force = system.getForce(i)
    print(f"Force {i}: {force}")

for force in system.getForces():
    force.setForceGroup(0)
force = system.getForce(6)
print('Selected: 6', force, 'to group1')
force.setForceGroup(1)

# force = system.getForce(5)
# print('Selected: 5', force, 'to group2')
# force.setForceGroup(2)


print("=================================================================")
params = np.loadtxt('iamd_param.dat')
a = params[:,0]*4.184
E = params[:,1]*4.184
M = params[:,2]*4.184
integrator = IaMDLIntegrator(temperature, 1.0, dt, 1, a, E, M, 0)
# integrator = LangevinIntegrator(temperature,friction, dt)
integrator.setConstraintTolerance(constraintTolerance)
simulation = Simulation(topology, system, integrator, platform, platformProperties)
simulation.context.setPositions(positions)

# # Minimize and Equilibrate
print('Performing energy minimization...')
simulation.minimizeEnergy()
# # let's save a PDB of the last frame of the simulation
lastpositions = simulation.context.getState(getPositions=True).getPositions()
PDBFile.writeFile(top.topology, lastpositions, open(outfile+'-em.pdb', 'w'))

# print('Equilibrating...')
# simulation.reporters.append(StateDataReporter(stdout, 1000, step=True, potentialEnergy=True, temperature=True, speed=True, totalSteps=eqsteps, separator='\t'))
# simulation.context.setVelocitiesToTemperature(temperature)
# simulation.step(eqsteps)

# print('Running Simulated Annealing MD')
# # every int(eqsteps/6) steps raise the temperature by 5 K, ending at 300 K
# T = 50*kelvin
# simulation.context.setVelocitiesToTemperature(T)
# for i in range(6):
#     simulation.step( int(eqsteps/6) )
#     integrator.setTemperature(T+(i*T))
#     barostat.setDefaultTemperature(T+(i*T))

# # let's also save a PDB of the last frame of the simulation
# lastpositions = simulation.context.getState(getPositions=True).getPositions()
# PDBFile.writeFile(top.topology, lastpositions, open(outfile+'-eq.pdb', 'w'))

# exit()
# Simulate
print('Simulating...')
simulation.reporters.append(dcdReporter)
simulation.reporters.append(chkReporter)
# simulation.saveCheckpoint('state.chk') # Same like the above!
# simulation.loadCheckpoint('state.chk') # Only for restart !
# Open checkpoint file like the follows better:
# with open("restart.chk",'rb') as f:
#     sim.context.loadCheckpoint(f.read())
# simulation.reporters.append(pdbReporter)
simulation.reporters.append(datReporter0)
simulation.reporters.append(datReporter1)
simulation.reporters.append(datReporter2)
simulation.reporters.append(EnergyReporter(outfile+'.eng', exsteps, [0, 1]))
simulation.reporters.append(StateDataReporter(stdout, 50000, step=True, potentialEnergy=True, temperature=True, speed=True, totalSteps=mdsteps, separator=','))
simulation.currentStep = 0
simulation.context.setVelocitiesToTemperature(temperature)
simulation.step(mdsteps)

# let's also save a PDB of the last frame of the simulation
lastpositions = simulation.context.getState(getPositions=True).getPositions()
PDBFile.writeFile(top.topology, lastpositions, open(outfile+'-md.pdb', 'w'))
