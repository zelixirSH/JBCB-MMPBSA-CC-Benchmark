# This script was generated by OpenMM-Setup on 2021-05-08.
from openmm import *
from simtk.openmm.app import *
from simtk.unit import *
from sys import stdout,argv
import mdtraj as md
import numpy as np

# Input Files
pdbfile = "plpro-7sdr.pdb"
grofile = "plpro-7sdr.gro"
outfile = "plpro-7sdr"
gpuid = '0'
topfile = "topol.top"


# Input Files
gro = GromacsGroFile(grofile)
top = GromacsTopFile(topfile, includeDir='/user/bigfacility/Apps/miniconda3/envs/automd/share/gromacs/top',
    periodicBoxVectors=gro.getPeriodicBoxVectors())

# System Configuration
nonbondedMethod = PME
nonbondedCutoff = 1.0*nanometers
ewaldErrorTolerance = 0.0005
constraints = HBonds
rigidWater = True
constraintTolerance = 0.000001
hydrogenMass = 4.0*amu

# Integration Options
dt = 0.004 * picoseconds
temperature = 300*kelvin
friction = 1.0/picosecond
pressure = 1.0*atmospheres
barostatInterval = 25

# Simulation Options
emsteps =       1000       # default
eqsteps =    1250000       # 
mdsteps = 2500000000       # 
exsteps =     250000       # 

platform = Platform.getPlatformByName('CUDA')
platformProperties = {'Precision': 'mixed',"DeviceIndex":gpuid}
#platformProperties["DeviceIndex"] = "0"
os.system("export OPENMM_CPU_THREADS=8")

# Output Options
dcdReporter  = DCDReporter(outfile+'.dcd', exsteps)
# pdbReporter  = PDBReporter(outfile+'.pdb', exsteps)
chkReporter  = CheckpointReporter(outfile+'.chk', exsteps*10)
datReporter0 = StateDataReporter(outfile+'.log', exsteps, totalSteps=mdsteps,
               step=True, speed=True, progress=True, potentialEnergy=True, 
               temperature=True,volume=True, separator=',')
datReporter1 = StateDataReporter(stdout, exsteps, step=True,
               time=True, potentialEnergy=True, kineticEnergy=True, totalEnergy=True,
               temperature=True, progress=True, volume=True, density=True,
               remainingTime=True, speed=True, totalSteps=mdsteps, separator=',')
datReporter2 = StateDataReporter(outfile+'.csv', exsteps, step=True,
               time=True, potentialEnergy=True, kineticEnergy=True, totalEnergy=True,
               temperature=True, progress=True, volume=True, density=True,
               remainingTime=True, speed=True, totalSteps=mdsteps, separator=',')

# Prepare the Simulation
print('Building system...')
topology = top.topology
positions = gro.positions
system = top.createSystem(nonbondedMethod=nonbondedMethod, nonbondedCutoff=nonbondedCutoff,
    constraints=constraints, rigidWater=rigidWater, ewaldErrorTolerance=ewaldErrorTolerance, hydrogenMass=hydrogenMass)
barostat = MonteCarloBarostat(pressure, temperature, barostatInterval)
system.addForce(barostat)
print("=================================================================")
# pdb = PDBFile(pdbfile)
# restraint = CustomExternalForce('k*periodicdistance(x, y, z, x0, y0, z0)^2')
# restraint.addGlobalParameter('k', 10000.0*kilojoules_per_mole/nanometer)
# restraint.addPerParticleParameter('x0')
# restraint.addPerParticleParameter('y0')
# restraint.addPerParticleParameter('z0')
# print("=================================================================")
# i = 0 
# for atom in pdb.topology.atoms():
#     if atom.name == 'CA' or atom.name == 'C' or atom.name == 'N' or atom.name == 'O' :
#         if i < 190: restraint.addParticle(atom.index, pdb.positions[atom.index])
#         i += 1



res1 = 23
res2 = 189
res3 = 127

traj = md.load(pdbfile)
r1_atoms = traj.top.select(f'resid {res1-1}')
r2_atoms = traj.top.select(f'resid {res2-1}')
r3_atoms = traj.top.select(f'resid {res3-1}')

g1_res = []
g2_res = []
g3_res = []

# for i in range(traj.top.n_residues):
#     atoms = traj.top.select(f'protein and resid {i}')
#     if atoms.size != 0:
#         dis1 = md.compute_distances(traj, np.array([[i, j] for i in r1_atoms for j in atoms]))
#         dis2 = md.compute_distances(traj, np.array([[i, j] for i in r2_atoms for j in atoms]))
#         dis3 = md.compute_distances(traj, np.array([[i, j] for i in r3_atoms for j in atoms]))
#         if np.min(dis1) <= 2:
#             g1_res.append(i)
#         if np.min(dis2) <= 2:
#             g2_res.append(i)
#         if np.min(dis3) <= 1:
#             g3_res.append(i)

g1_res = [i for i in range(91)]
g2_res = [i for i in range(126, 154)] + [i for i in range(170, 175)]
g3_res = [i for i in range(180, 237)] + [i for i in range(307, 312)]
print(f'g1_res:{g1_res}\ng2_res:{g2_res}\ng3_res:{g3_res}')

g1_atoms = traj.top.select(' '.join([f'resid {i}' for i in g1_res]))
g2_atoms = traj.top.select(' '.join([f'resid {i}' for i in g2_res]))
g3_atoms = traj.top.select(' '.join([f'resid {i}' for i in g3_res]))
# print(f'g1_atoms:{g1_atoms}\ng2_atoms:{g2_atoms}\ng3_atoms:{g3_atoms}')

traj1 = md.load(pdbfile)
traj_fix1 = traj1.restrict_atoms(g1_atoms)
centroid1 = md.compute_center_of_mass(traj_fix1)[0]
traj2 = md.load(pdbfile)
traj_fix2 = traj2.restrict_atoms(g2_atoms)
centroid2 = md.compute_center_of_mass(traj_fix2)[0]
traj3 = md.load(pdbfile)
traj_fix3 = traj3.restrict_atoms(g3_atoms)
centroid3 = md.compute_center_of_mass(traj_fix3)[0]
print(f'centroid1:{centroid1}\ncentroid2:{centroid2}\ncentroid3:{centroid3}')

restraint = CustomCentroidBondForce(1, 'k*step(dr)*dr;dr=pointdistance(x1,y1,z1,x0,y0,z0)^2-0.1')
restraint.addGlobalParameter('k', 50.0*kilojoules_per_mole/nanometer)
restraint.addGroup(g1_atoms);
restraint.addGlobalParameter('x0', centroid1[0])
restraint.addGlobalParameter('y0', centroid1[1])
restraint.addGlobalParameter('z0', centroid1[2])
restraint.addBond([0])
system.addForce(restraint)

restraint = CustomCentroidBondForce(1, 'k*step(dr)*dr;dr=pointdistance(x1,y1,z1,a0,b0,c0)^2-0.1')
restraint.addGlobalParameter('k', 50.0*kilojoules_per_mole/nanometer)
restraint.addGroup(g2_atoms);
restraint.addGlobalParameter('a0', centroid2[0])
restraint.addGlobalParameter('b0', centroid2[1])
restraint.addGlobalParameter('c0', centroid2[2])
restraint.addBond([0])
system.addForce(restraint)

restraint = CustomCentroidBondForce(1, 'k*step(dr)*dr;dr=pointdistance(x1,y1,z1,d0,e0,f0)^2-0.1')
restraint.addGlobalParameter('k', 50.0*kilojoules_per_mole/nanometer)
restraint.addGroup(g3_atoms);
restraint.addGlobalParameter('d0', centroid3[0])
restraint.addGlobalParameter('e0', centroid3[1])
restraint.addGlobalParameter('f0', centroid3[2])
restraint.addBond([0])
system.addForce(restraint)

with open(outfile+'-restraint.log', 'w') as f:
    f.write(f'sel_res1:{res1}\nsel_res2:{res2}\nsel_res3:{res3}\n\n')
    f.write(f'g1_res:{g1_res}\ng2_res:{g2_res}\ng3_res:{g3_res}\n\n')
    f.write(f'g1_atoms:{g1_atoms}\ng2_atoms:{g2_atoms}\ng3_atoms:{g3_atoms}\n\n')
    f.write(f'centroid1:{centroid1}\ncentroid2:{centroid2}\ncentroid3:{centroid3}\n\n')

print("=================================================================")
integrator = LangevinIntegrator(temperature,friction, dt)
integrator.setConstraintTolerance(constraintTolerance)
simulation = Simulation(topology, system, integrator, platform, platformProperties)
simulation.context.setPositions(positions)

# # Minimize and Equilibrate
# print('Performing energy minimization...')
# simulation.minimizeEnergy()
# # let's save a PDB of the last frame of the simulation
# lastpositions = simulation.context.getState(getPositions=True).getPositions()
# PDBFile.writeFile(top.topology, lastpositions, open(outfile+'-em.pdb', 'w'))

# print('Equilibrating...')
# simulation.reporters.append(StateDataReporter(stdout, 1000, step=True, potentialEnergy=True, temperature=True, speed=True, totalSteps=eqsteps, separator='\t'))
# simulation.context.setVelocitiesToTemperature(temperature)
# simulation.step(eqsteps)

# print('Running Simulated Annealing MD')
# # every int(eqsteps/6) steps raise the temperature by 5 K, ending at 300 K
# T = 50*kelvin
# simulation.context.setVelocitiesToTemperature(T)
# for i in range(6):
#     simulation.step( int(eqsteps/6) )
#     integrator.setTemperature(T+(i*T))
#     barostat.setDefaultTemperature(T+(i*T))

# let's also save a PDB of the last frame of the simulation
# lastpositions = simulation.context.getState(getPositions=True).getPositions()
# PDBFile.writeFile(top.topology, lastpositions, open(outfile+'-eq.pdb', 'w'))

# exit()
# Simulate
print('Simulating...')
simulation.reporters.append(dcdReporter)
simulation.reporters.append(chkReporter)
#simulation.saveCheckpoint('state.chk') # Same like the above!
#simulation.loadCheckpoint('state.chk') # Only for restart !
# Open checkpoint file like the follows better:
#with open("restart.chk",'rb') as f:
#    sim.context.loadCheckpoint(f.read())
# simulation.reporters.append(pdbReporter)
simulation.reporters.append(datReporter0)
simulation.reporters.append(datReporter1)
simulation.reporters.append(datReporter2)
simulation.reporters.append(StateDataReporter(stdout, 5000, step=True, potentialEnergy=True, temperature=True, speed=True, totalSteps=mdsteps, separator=','))
simulation.currentStep = 0
simulation.context.setVelocitiesToTemperature(temperature)
simulation.step(mdsteps)

# let's also save a PDB of the last frame of the simulation
lastpositions = simulation.context.getState(getPositions=True).getPositions()
PDBFile.writeFile(top.topology, lastpositions, open(outfile+'-md.pdb', 'w'))
